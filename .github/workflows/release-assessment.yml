name: Release Assessment

on:
  pull_request:
    types: [closed]
    branches: [dev]

jobs:
  assess-release:
    name: Assess Release Readiness
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history needed for tags and commit analysis
      
      - name: Analyze commits for release assessment
        id: assessment
        run: |
          # Get last tag (default to v0.0.0 if none exists)
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Last tag: $LAST_TAG"
          
          # Count commits since last tag
          if [ "$LAST_TAG" = "v0.0.0" ]; then
            COMMIT_COUNT=$(git rev-list HEAD --count)
          else
            COMMIT_COUNT=$(git rev-list ${LAST_TAG}..HEAD --count)
          fi
          echo "Commits since last tag: $COMMIT_COUNT"
          
          # Check for different commit types since last tag
          if [ "$LAST_TAG" = "v0.0.0" ]; then
            COMMIT_LOG=$(git log --oneline)
          else
            COMMIT_LOG=$(git log ${LAST_TAG}..HEAD --oneline)
          fi
          
          # Count feat: commits
          FEAT_COUNT=$(echo "$COMMIT_LOG" | grep -cE "^[a-f0-9]+ feat(\(.+\))?:" || echo "0")
          
          # Check for breaking changes (both BREAKING CHANGE in body and feat!/fix! notation)
          if [ "$LAST_TAG" = "v0.0.0" ]; then
            BREAKING_COUNT=$(git log --oneline --grep="BREAKING CHANGE" | wc -l | tr -d ' ')
          else
            BREAKING_COUNT=$(git log ${LAST_TAG}..HEAD --oneline --grep="BREAKING CHANGE" | wc -l | tr -d ' ')
          fi
          # Detect feat!/fix! notation by parsing oneline output directly
          BREAKING_BANG=$(echo "$COMMIT_LOG" | grep -cE "^[a-f0-9]+ (feat|fix)(\(.+\))?!:" || echo "0")
          HAS_BREAKING=$((BREAKING_COUNT + BREAKING_BANG))
          
          echo "Feature commits: $FEAT_COUNT"
          echo "Breaking changes: $HAS_BREAKING"
          
          # Determine highest change type and bump
          if [ "$HAS_BREAKING" -gt 0 ]; then
            HIGHEST_TYPE="BREAKING CHANGE"
            BUMP="MAJOR"
          elif [ "$FEAT_COUNT" -gt 0 ]; then
            HIGHEST_TYPE="feat"
            BUMP="MINOR"
          else
            HIGHEST_TYPE="fix/chore/docs"
            BUMP="PATCH"
          fi
          
          # Parse current version and calculate suggested version
          MAJOR=$(echo $LAST_TAG | sed 's/v//' | cut -d. -f1)
          MINOR=$(echo $LAST_TAG | sed 's/v//' | cut -d. -f2)
          PATCH=$(echo $LAST_TAG | sed 's/v//' | cut -d. -f3)
          
          case $BUMP in
            MAJOR) SUGGESTED="v$((MAJOR+1)).0.0" ;;
            MINOR) SUGGESTED="v${MAJOR}.$((MINOR+1)).0" ;;
            PATCH) SUGGESTED="v${MAJOR}.${MINOR}.$((PATCH+1))" ;;
          esac
          
          echo "Suggested version: $SUGGESTED"
          
          # Set outputs
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT
          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          echo "feat_count=$FEAT_COUNT" >> $GITHUB_OUTPUT
          echo "has_breaking=$HAS_BREAKING" >> $GITHUB_OUTPUT
          echo "highest_type=$HIGHEST_TYPE" >> $GITHUB_OUTPUT
          echo "bump=$BUMP" >> $GITHUB_OUTPUT
          echo "suggested=$SUGGESTED" >> $GITHUB_OUTPUT
      
      # Create or update Release Candidate issue (only if feat: or breaking changes)
      - name: Create or update Release Candidate issue
        if: ${{ steps.assessment.outputs.feat_count > 0 || steps.assessment.outputs.has_breaking > 0 }}
        uses: actions/github-script@v7
        with:
          script: |
            const label = 'release-candidate';
            const title = 'Release Candidate';
            
            const body = `## Release Assessment

            New feature work has been merged to \`dev\`. Consider cutting a release.

            | Metric | Value |
            |--------|-------|
            | **Current version** | \`${process.env.LAST_TAG}\` |
            | **Commits since release** | ${process.env.COMMIT_COUNT} |
            | **Highest change type** | ${process.env.HIGHEST_TYPE} |
            | **Recommended bump** | ${process.env.BUMP} |
            | **Suggested version** | \`${process.env.SUGGESTED}\` |

            ### Recent PRs included

            - ${context.payload.pull_request.title} (#${context.payload.pull_request.number})

            ### Actions

            Comment one of the following commands:

            | Command | Action |
            |---------|--------|
            | \`/approve-release\` | Creates a PR from \`dev\` to \`main\` |
            | \`/reject-release\` | Closes this issue without releasing |

            After the release PR is merged, tagging and GitHub Release creation happen automatically.

            ---

            **Manual release:** See [Release Process](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/dev/docs/release-process.md)

            ---
            *Last updated: ${new Date().toISOString()}*
            *Triggered by: #${context.payload.pull_request.number}*`;

            // Check if release-candidate label exists, create if not
            try {
              await github.rest.issues.getLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: label
              });
            } catch (e) {
              if (e.status === 404) {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label,
                  color: '0E8A16',
                  description: 'Indicates dev branch is ready for a release'
                });
              }
            }

            // Find existing open release-candidate issue
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: label,
              state: 'open'
            });

            if (issues.data.length > 0) {
              // Update existing issue
              const existingIssue = issues.data[0];
              const existingBody = existingIssue.body || '';
              
              // Extract existing PR list from the issue body
              const prListMatch = existingBody.match(/### Recent PRs included\n\n([\s\S]*?)\n\n### Actions/);
              const existingPRs = prListMatch ? prListMatch[1].trim() : '';
              
              // Build new PR list with current PR appended
              const currentPR = `- ${context.payload.pull_request.title} (#${context.payload.pull_request.number})`;
              const newPRList = existingPRs ? `${existingPRs}\n${currentPR}` : currentPR;
              
              // Build updated body with the accumulated PR list
              const updatedBody = `## Release Assessment

            New feature work has been merged to \`dev\`. Consider cutting a release.

            | Metric | Value |
            |--------|-------|
            | **Current version** | \`${process.env.LAST_TAG}\` |
            | **Commits since release** | ${process.env.COMMIT_COUNT} |
            | **Highest change type** | ${process.env.HIGHEST_TYPE} |
            | **Recommended bump** | ${process.env.BUMP} |
            | **Suggested version** | \`${process.env.SUGGESTED}\` |

            ### Recent PRs included

            ${newPRList}

            ### Actions

            Comment one of the following commands:

            | Command | Action |
            |---------|--------|
            | \`/approve-release\` | Creates a PR from \`dev\` to \`main\` |
            | \`/reject-release\` | Closes this issue without releasing |

            After the release PR is merged, tagging and GitHub Release creation happen automatically.

            ---

            **Manual release:** See [Release Process](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/dev/docs/release-process.md)

            ---
            *Last updated: ${new Date().toISOString()}*
            *Triggered by: #${context.payload.pull_request.number}*`;
              
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: updatedBody
              });
              
              // Add a comment noting the update
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `Updated: PR #${context.payload.pull_request.number} merged. Suggested version is now \`${process.env.SUGGESTED}\`.`
              });
              
              console.log(`Updated existing issue #${existingIssue.number}`);
            } else {
              // Create new issue
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: [label]
              });
              
              console.log(`Created new issue #${newIssue.data.number}`);
            }
        env:
          LAST_TAG: ${{ steps.assessment.outputs.last_tag }}
          COMMIT_COUNT: ${{ steps.assessment.outputs.commit_count }}
          HIGHEST_TYPE: ${{ steps.assessment.outputs.highest_type }}
          BUMP: ${{ steps.assessment.outputs.bump }}
          SUGGESTED: ${{ steps.assessment.outputs.suggested }}
